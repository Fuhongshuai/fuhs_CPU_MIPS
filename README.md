# CPU_MIPS32位指令
CPU_OPENMIPS指令编写

---

## 第一条指令ori

## 逻辑、移位与nop

1. 相关问题（流水线引入了并发竞争？每个阶段可视为单独的HDL模块）

   1. 数据相关：RAW WAR WAW ==> OpenMIPS只存在RAW相关，例如：ori $1, $0, 0x1100; ori $2, $1, 0x0020

      1. p111 如果读取的寄存器是在下一个时钟上升沿要写入的，那么直接将要写入的数据作为结果输出

         ```
         if( reg2_read_o1'b1 && ex_wreg_i1'b1 && ex_wd_i==reg2_addr_o begin reg2_o <= ex_wdata_i; ...
         ```

      2. 插入暂停周期

      3. 编译器调度（指令重排）

      4. 数据前推

## 移动

​        MIPS32指令集架构中定义的移动操作指令共有6条：movn、movz、mfhi、mthi、mflo、mtlo，后4条指令涉及到了对特殊寄存器HI、LO的读写操作，截止到本章，我们的OpenMIPS处理器只实现了32个通用寄存器、以及PC，所有的指令也只是对32个通用寄存器进行操作，还没有涉及特殊寄存器。

## 算术

​        虽然简单算术操作指令的数目比较多，有15条，但实现方式都是相似的，与前几章逻辑、移位操作指令的实现方式也很类似，不需要增加新的模块、新的接口，只需要修改流水线译码阶段的ID模块、执行阶段的EX模块即可。实现思路如下。

​      （1）修改流水线译码阶段的ID模块，添加对上述简单算术操作指令的译码，给出运算类型alusel_o、运算子类型aluop_o、要写入的目的寄存器地址wd_o等信息，同时根据需要读取地址为rs、rt的通用寄存器的值。

​      （2）修改流水线执行阶段的EX模块，依据传入的信息，进行运算，得到运算结果，确定最终要写目的寄存器的信息（包含：是否写、写入的目的寄存器地址、写入的值），并将这些信息传递到访存阶段。

​      （3）上述信息会一直传递到回写阶段，最后修改目的寄存器。

## 转移

1. 延迟槽
   1. 在执行阶段如果转移，会有2条无效指令
   2. 仍然会导致已经进入取指阶段的指令无效：可在译码阶段进行转移判断，避免浪费时钟周期
2. p210 bal是bgezal的特殊情况（rs=0）
3. MIPS32指令集架构中定义的转移指令共有14条，可分为如下两类。
   -  跳转指令： jr 、jalr 、j 、jal
   -  分支指令：b、bal、beq、bgez、bgezal、bgtz、blez、bltz、bltzal、bne

## Load/Store

1、加载指令实现思路

​      加载指令在译码阶段进行译码，得到运算类型alusel_o、aluop_o，以及要写的目的寄存器信息。这些信息传递到执行阶段，然后又传递到访存阶段，访存阶段依据这些信息，设置对数据存储器RAM的访问信号。从RAM读取回来的数据需要按照加载指令的类型、加载地址进行对齐调整，调整后的结果作为最终要写入目的寄存器的数据。

​      2、存储指令实现思路

​      存储指令在译码阶段进行译码，得到运算类型alusel_o、aluop_o，以及要存储的数据。这些信息传递到执行阶段，然后又传递到访存阶段，访存阶段依据这些信息，设置对数据存储器RAM的访问信号，将数据写入RAM。

## 流水线数据相关的处理

​       其中相隔2条指令存在数据相关（即流水线译码、回写阶段存在数据相关）这种情况，在第4章设计的Regfile模块中已经得到了解决，Regfile模块部分代码如下。

```
module regfile(
	......
);
 
	......
	
/****************************************************************
***********           第三段：读端口1的读操作           *********
*****************************************************************/
 
// raddr1是读地址、waddr是写地址、we是写使能、wdata是要写入的数据
	always @ (*) begin
 
	  ......
 
	  end else if((raddr1 == waddr) && (we == `WriteEnable) 
	  	            && (re1 == `ReadEnable)) begin
	    rdata1 <= wdata;
 
	  ......
 
	end
 
/****************************************************************
***********           第四段：读端口2的读操作            *********
*****************************************************************/
 
// raddr2是读地址、waddr是写地址、we是写使能、wdata是要写入的数据
	always @ (*) begin
 
	  ......
 
	  end else if((raddr2 == waddr) && (we == `WriteEnable) 
	  	            && (re2 == `ReadEnable)) begin
	    rdata2 <= wdata;
 
	  ......
 
	end
 
endmodule
```

